\documentclass{book}
\usepackage{a4}
\usepackage{palatino}
\usepackage{natbib}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{upgreek}
\usepackage{url}

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff


\newcommand{\M}[1]{\mathsf{#1}}
\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\C}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}
\newcommand{\T}[1]{\raisebox{0.02in}{\tiny\green{\textsc{#1}}}}

\newcommand{\us}[1]{\_\!#1\!\_}
\newtheorem{theorem}{Theorem}
\newtheorem{exe}{Exercise}[chapter]

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%



\newcommand{\nudge}[1]{\marginpar{\footnotesize #1}}


\begin{document}
  \title{Software Foundations}
  \maketitle



\chapter*{Preface}

\section{Welcome}

This electronic book is a Agda version of Pierce's Coq book named Software Foundations.

\section{Overview}

...




\chapter{Basic Functional Programming in Agda}\label{basics}

\section{Introduction}\label{basics-introduction}

The functional programming style brings programming closer to mathematics: 
If a procedure or method has no side effects, then pretty much all you need 
to understand about it is how it maps inputs to outputs --- that is, you can 
think of its behavior as just computing a mathematical function. This is one 
reason for the word ``functional'' in ``functional programming.'' This direct 
connection between programs and simple mathematical objects supports both sound 
informal reasoning and formal proofs of correctness.

The other sense in which functional programming is ``functional'' is that it 
emphasizes the use of functions (or methods) as \textit{first-class values} --- i.e., 
values that can be passed as arguments to other functions, returned as results, 
stored in data structures, etc. The recognition that functions can be treated 
as data in this way enables a host of useful idioms, as we will see.
Other common features of functional languages include \textit{algebraic data types} and 
\textit{pattern matching}, which make it easy to construct and manipulate rich data 
structures, and sophisticated \textit{polymorphic type systems} that support abstraction 
and code reuse. Agda shares all of these features.

\section{Enumerated Types}\label{enumerated-types}

One unusual aspect of Coq is that its set of built-in features is extremely small. For 
example, instead of providing the usual palette of atomic data types (booleans, integers, strings, etc.), 
Agda offers an extremely powerful mechanism for defining new data types from scratch --- so powerful that 
all these familiar types arise as instances.

Agda has a standard library that comes with definitions of booleans, numbers, and many common data structures 
like lists. But there is nothing magic or primitive about these library definitions: they are ordinary user code.
To see how this works, let's start with a very simple example.

\subsection{Days of Week}\label{days-of-week}

The following declaration tells Agda that we are defining a new set of data values --- a type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\V{Day}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Monday}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\V{Day}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Tuesday}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\V{Day}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Wednesday}\;\mathbin{:}\;\V{Day}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Thursday}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\V{Day}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Friday}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\V{Day}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Saturday}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\V{Day}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Sunday}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\V{Day}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The type is called Day, and its members are Monday, Tuesday, etc. The second through eighth 
lines of the definition can be read ``monday is a day, tuesday is a day, etc.''

Having defined Day, we can write functions that operate on days.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{nextDay}\;\mathbin{:}\;\V{Day}\;\blue{\rightarrow}\;\V{Day}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Monday}\;{}\<[19]%
\>[19]{}\mathrel{=}\;\V{Tuesday}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Tuesday}\;{}\<[19]%
\>[19]{}\mathrel{=}\;\V{Wednesday}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Wednesday}\;\mathrel{=}\;\V{Thursday}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Thursday}\;{}\<[19]%
\>[19]{}\mathrel{=}\;\V{Friday}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Friday}\;{}\<[19]%
\>[19]{}\mathrel{=}\;\V{Saturday}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Saturday}\;{}\<[19]%
\>[19]{}\mathrel{=}\;\V{Sunday}{}\<[E]%
\\
\>[B]{}\F{nextDay}\;\V{Sunday}\;{}\<[19]%
\>[19]{}\mathrel{=}\;\V{Monday}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

One thing to note is that the argument and return types of this function are explicitly 
declared. Like most functional programming languages, Agda can often work out these types 
even if they are not given explicitly --- i.e., it performs some type inference --- but 
we'll always include them to make reading easier.

Having defined a function, we should check that it works on some examples. There are 
actually two different ways to do this in Agda. One uses the notion of equality and
another uses the interactive emacs mode. To test the new defined \ensuremath{\F{nextDay}} function,
just type C-c C-n and type \ensuremath{\F{nextDay}} \ensuremath{\V{Friday}} on the emacs buffer in order to Agda evaluate
the expression to \ensuremath{\V{Saturday}}.

\subsection{Booleans}\label{booleans}

In a similar way, we can define the type \ensuremath{\V{Bool}} of booleans, with members true and false.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\V{Bool}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{True}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{False}\;\mathbin{:}\;\V{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Although we are rolling our own booleans here for the sake of building up everything from 
scratch, Agda does, of course, provide a default implementation of the booleans in its standard 
library, together with a multitude of useful functions and lemmas. 
Whenever possible, we'll name our own definitions and theorems so that they exactly coincide 
with the ones in the standard library.

Functions over booleans can be defined in the same way as above:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\neg \;\mathbin{:}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\neg \;\V{True}\;{}\<[11]%
\>[11]{}\mathrel{=}\;\V{False}{}\<[E]%
\\
\>[B]{}\neg \;\V{False}\;\mathrel{=}\;\V{True}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{and}\;\mathbin{:}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{and}\;\V{True}\;\F{t}\;{}\<[13]%
\>[13]{}\mathrel{=}\;\F{t}{}\<[E]%
\\
\>[B]{}\F{and}\;\V{False}\;\anonymous \;\mathrel{=}\;\V{False}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{or}\;\mathbin{:}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{or}\;\V{True}\;\anonymous \;{}\<[12]%
\>[12]{}\mathrel{=}\;\V{True}{}\<[E]%
\\
\>[B]{}\F{or}\;\V{False}\;\F{t}\;\mathrel{=}\;\F{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Agda supports the so called mixfix operator syntax and unicode identifiers that are extensively used 
in the standard library. We believe that using these only serves as an additional barrier for newbies
learning Agda. So, we will avoid it.

Again, we can test these definitions using the emacs mode through the command C-c C-n.

\begin{exe}[The nand logic operator]
Define the following function to represent the nand logic operator. Nand connective is defined using
the following truth table:
\begin{center}
\begin{tabular}{ccc}
$A$       & $B$        & \ensuremath{\F{nand}} $A$ $B$\\
\ensuremath{\V{False}} & \ensuremath{\V{False}}  &  \ensuremath{\V{True}} \\
\ensuremath{\V{False}} & \ensuremath{\V{True}}   &  \ensuremath{\V{True}} \\
\ensuremath{\V{True}}  & \ensuremath{\V{False}}  &  \ensuremath{\V{True}} \\
\ensuremath{\V{True}}  & \ensuremath{\V{True}}   &  \ensuremath{\V{False}} \\
\end{tabular}
\end{center}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{nand}\;\mathbin{:}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{nand}\;\F{a}\;\F{b}\;\mathrel{=}\;\orange{?}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}[The and3 function]
Implement the \ensuremath{\F{and3}} function that returns the conjunction of 3 boolean values.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{and3}\;\mathbin{:}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{and3}\;\F{a}\;\F{b}\;\F{c}\;\mathrel{=}\;\orange{?}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\subsection{Function Types}\label{function-types}

We can use the emacs interactive mode to deduce an expression types. Just type
C-c C-d and enter a expression in the emacs buffer to Agda give this expression type.

As an example, entering the expression \ensuremath{\F{and}} \ensuremath{\V{True}}, Agda will return the type
\ensuremath{\V{Bool}\;\blue{\rightarrow}\;\V{Bool}}. Entering \ensuremath{\neg }, will also return \ensuremath{\V{Bool}\;\blue{\rightarrow}\;\V{Bool}}.

\subsection{Numbers}\label{numbers}

The types we have defined so far are examples of ``enumerated types'': their definitions 
explicitly enumerate a finite set of elements. A more interesting way of defining a type 
is to give a collection of ``inductive rules'' describing its elements. For example, we 
can define the natural numbers as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\V{Nat}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\F{zero}\;\mathbin{:}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\F{suc}\;{}\<[8]%
\>[8]{}\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The clauses of this definition can be read:
\begin{itemize}
  \item \ensuremath{\F{zero}} is a natural number.
  \item \ensuremath{\F{suc}}  is a ``constructor'' that takes a natural number and yields another one --- 
        that is, if \ensuremath{\F{n}} is a natural number, then \ensuremath{\F{suc}\;\F{n}} is too.
\end{itemize}

Agda compiler provides some pragmas to enable numeric literals, in order to avoid the
verbose notation of $n$-aries \ensuremath{\F{suc}}s.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mbox{\enskip\{-\# BUILTIN NATURAL Nat  \#-\}\enskip}{}\<[E]%
\\
\>[B]{}\mbox{\enskip\{-\# BUILTIN ZERO zero  \#-\}\enskip}{}\<[E]%
\\
\>[B]{}\mbox{\enskip\{-\# BUILTIN SUC suc  \#-\}\enskip}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Let's look at this in a little more detail. 

Every inductively defined set (Day, Nat, Bool, etc.) is actually a set of expressions. 
The definition of \ensuremath{\V{Nat}} says how expressions in the set \ensuremath{\V{Nat}} can be constructed:
\begin{itemize}
  \item the expression \ensuremath{\F{zero}} belongs to the set \ensuremath{\V{Nat}};
  \item if \ensuremath{\F{n}} is an expression belonging to the set \ensuremath{\V{Nat}}, then \ensuremath{\F{suc}\;\F{n}} is also an 
        expression belonging to the set \ensuremath{\V{Nat}}; and expressions formed in these two ways 
        are the only ones belonging to the set \ensuremath{\V{Nat}}.
\end{itemize}
The same rules apply for our definitions of \ensuremath{\V{Day}} and \ensuremath{\V{Bool}}. The annotations we used 
for their constructors are analogous to the one for the \ensuremath{\F{zero}} constructor, and indicate 
that each of those constructors doesn't take any arguments.

These three conditions are the precise force of the inductive declaration. They imply 
that the expression \ensuremath{\F{zero}}, the expression \ensuremath{\F{suc}\;\F{zero}}, the expression \ensuremath{\F{suc}\;(\F{suc}\;\F{zero})}, 
the expression \ensuremath{\F{suc}\;(\F{suc}\;(\F{suc}\;\F{zero}))}, and so on all belong to the set \ensuremath{\V{Nat}}, while other 
expressions like \ensuremath{\V{True}}, \ensuremath{\F{and}\;\V{True}\;\V{False}}, and \ensuremath{\F{suc}\;(\F{suc}\;\V{False})} do not.

We can write simple functions that pattern match on natural numbers just as we did above --- 
for example, the predecessor function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{pred}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{pred}\;\F{zero}\;{}\<[14]%
\>[14]{}\mathrel{=}\;\F{zero}{}\<[E]%
\\
\>[B]{}\F{pred}\;(\F{suc}\;\F{n})\;\mathrel{=}\;\F{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

These are all things that can be applied to a number to yield a number. However, there 
is a fundamental difference: functions like pred and minustwo come with computation rules 
--- e.g., the definition of \ensuremath{\F{pred}} says that \ensuremath{\F{pred}\;\F{2}} can be simplified to 1 --- while 
the definition of \ensuremath{\F{suc}} has no such behavior attached. Although it is like a function 
in the sense that it can be applied to an argument, it does not do anything at all!

For most function definitions over numbers, pure pattern matching is not enough: we 
also need recursion. For example, to check that a number \ensuremath{\F{n}} is even, we may need 
to recursively check whether $n-2$ is even. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{evenb}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{evenb}\;\F{zero}\;{}\<[21]%
\>[21]{}\mathrel{=}\;\V{True}{}\<[E]%
\\
\>[B]{}\F{evenb}\;(\F{suc}\;\F{zero})\;{}\<[21]%
\>[21]{}\mathrel{=}\;\V{False}{}\<[E]%
\\
\>[B]{}\F{evenb}\;(\F{suc}\;(\F{suc}\;\F{n}))\;\mathrel{=}\;\F{evenb}\;\F{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can define \ensuremath{\F{oddb}}, a function that tests if a natural number is odd, similarly or using
\ensuremath{\F{evenb}}.

\begin{exe}{Defining \ensuremath{\F{oddb}}}
Define the function \ensuremath{\F{oddb}} that tests if a number is odd, without recursion.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{oddb}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{oddb}\;\F{n}\;\mathrel{=}\;\orange{?}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

Naturally, we can also define multi-argument functions by recursion.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{\char95 +\char95 }\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{zero}\;\F{+}\;\F{m}\;\mathrel{=}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{suc}\;\F{n}\;\F{+}\;\F{m}\;\mathrel{=}\;\F{suc}\;(\F{n}\;\F{+}\;\F{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Adding three to two now gives us five, as we'd expect --- You can test it using C-c C-n, as you know.

The simplification that Coq performs to reach this conclusion can be visualized as follows:
\begin{flushleft}
\begin{tabular}{lc}
\ensuremath{\F{suc}\;(\F{suc}\;(\F{suc}\;\F{zero}))\;\F{+}\;\F{suc}\;(\F{suc}\;\F{zero})} & $\Rightarrow$\\
\ensuremath{\F{suc}\;(\F{suc}\;\F{zero})\;\F{+}\;\F{suc}\;(\F{suc}\;(\F{suc}\;\F{zero}))} & $\Rightarrow$\\
\ensuremath{\F{suc}\;\F{zero}\;\F{+}\;\F{suc}\;(\F{suc}\;(\F{suc}\;(\F{suc}\;\F{zero})))} & $\Rightarrow$\\
\ensuremath{\F{zero}\;\F{+}\;\F{suc}\;(\F{suc}\;(\F{suc}\;(\F{suc}\;(\F{suc}\;\F{zero}))))} & $\Rightarrow$\\
\ensuremath{\F{suc}\;(\F{suc}\;(\F{suc}\;(\F{suc}\;(\F{suc}\;\F{zero}))))} & \\
\end{tabular}
\end{flushleft}

Multiplication and subtraction over naturals are defined straightforwardly, by pattern matching.
The underscore represents a \textit{wildcard} pattern. Writing underscores in a pattern is the same as 
writing some variable that doesn't get used on the right-hand side. This avoids the need to invent 
a bogus variable name.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{\char95 *\char95 }\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{zero}\;\F{*}\;\F{m}\;{}\<[11]%
\>[11]{}\mathrel{=}\;\F{zero}{}\<[E]%
\\
\>[B]{}\F{suc}\;\F{n}\;\F{*}\;\F{m}\;\mathrel{=}\;\F{m}\;\F{+}\;(\F{n}\;\F{*}\;\F{m}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{\char95 -\char95 }\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{zero}\;{}\<[7]%
\>[7]{}\F{-}\;\anonymous \;{}\<[15]%
\>[15]{}\mathrel{=}\;\F{zero}{}\<[E]%
\\
\>[B]{}(\F{suc}\;\F{n})\;\F{-}\;\F{zero}\;{}\<[17]%
\>[17]{}\mathrel{=}\;\F{suc}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{suc}\;\F{n}\;\F{-}\;\F{suc}\;\F{m}\;\mathrel{=}\;\F{n}\;\F{-}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[factorial function]
Define a function to compute the factorial of a given natural number.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{factorial}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{factorial}\;\F{n}\;\mathrel{=}\;\orange{?}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

When we say that Agda comes with nothing built-in, we really mean it: 
even equality testing for numbers is a user-defined operation! The \ensuremath{\F{beq\char95 nat}} function tests natural 
numbers for equality, yielding a boolean. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{beqNat}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{beqNat}\;\F{zero}\;{}\<[16]%
\>[16]{}\F{zero}\;{}\<[24]%
\>[24]{}\mathrel{=}\;\V{True}{}\<[E]%
\\
\>[B]{}\F{beqNat}\;\F{zero}\;{}\<[16]%
\>[16]{}(\F{suc}\;\anonymous )\;\mathrel{=}\;\V{False}{}\<[E]%
\\
\>[B]{}\F{beqNat}\;(\F{suc}\;\anonymous )\;\F{zero}\;{}\<[24]%
\>[24]{}\mathrel{=}\;\V{False}{}\<[E]%
\\
\>[B]{}\F{beqNat}\;(\F{suc}\;\F{n})\;(\F{suc}\;\F{m})\;\mathrel{=}\;\F{beqNat}\;\F{n}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Similarly, the \ensuremath{\F{ble\char95 nat}} function tests natural numbers for less-or-equal, yielding a boolean.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{bleNat}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{bleNat}\;\F{zero}\;{}\<[16]%
\>[16]{}\anonymous \;{}\<[24]%
\>[24]{}\mathrel{=}\;\V{True}{}\<[E]%
\\
\>[B]{}\F{bleNat}\;(\F{suc}\;\F{n})\;\F{zero}\;{}\<[24]%
\>[24]{}\mathrel{=}\;\V{False}{}\<[E]%
\\
\>[B]{}\F{bleNat}\;(\F{suc}\;\F{n})\;(\F{suc}\;\F{m})\;\mathrel{=}\;\F{bleNat}\;\F{n}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Definition of \ensuremath{\F{blt\char95 nat}}]
The \ensuremath{\F{blt\char95 nat}} function tests natural numbers for less-than, yielding a boolean. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{bltNat}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{bltNat}\;\F{n}\;\F{m}\;\mathrel{=}\;\orange{?}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\section{Proof by Simplification}

\textbf{Little digression:}  In type theory based proof assistants, like Agda and Coq, there are
(at least) two notions of equality: the definitional equality and the propositional equality.
I need to put here some explanation about propositional equality. \textbf{End of little digression}.


Now that we've defined a few datatypes and functions, let's turn to the question of how to 
state and prove properties of their behavior. Actually, in a sense, we've already started 
doing this: each time we use C-c C-n in the previous sections makes a precise claim about the behavior 
of some function on some particular inputs. The proofs of these claims were always the same: 
use \ensuremath{\F{refl}} --- that has type \ensuremath{\F{x}\;\equiv \;\F{x}}, for each \ensuremath{\F{x}} --- to check that both sides of the = simplify to identical values.

The same sort of ``proof by simplification'' can be used to prove more interesting properties as well. 
For example, the fact that 0 is a ``neutral element'' for \ensuremath{\F{+}} on the left can be proved just by 
observing that \ensuremath{\F{0}\;\F{+}\;\F{n}} reduces to \ensuremath{\F{n}} no matter what \ensuremath{\F{n}} is, a fact that can be read directly off the definition of \ensuremath{\F{+}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lemmaPlus0N}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{0}\;\F{+}\;\F{n}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\F{lemmaPlus0N}\;\F{n}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Agda emacs mode uses some unicode notation for symbols. More information about unicode notation can be found at Agda wiki.

Agda follows the so-called \textit{Curry-Howard isomorphism} where types denote logical formulas and terms proofs. So, a proof
of a theorem just correspond to a function whose type denotes the formula being proved by the term defining the function.

Note that we've added the quantifier \ensuremath{\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})}, so that our theorem talks about all natural numbers \ensuremath{\F{n}}. 
In order to prove theorems of this form, we need to to be able to reason by assuming the existence of an arbitrary 
natural number \ensuremath{\F{n}}. This is achieved in the proof by considering the quantified variable \ensuremath{\F{n}} as a function parameter, 
putting it on the context as an hypothesis. With this, we can start the proof by saying "OK, suppose n is some arbitrary number."

Agda does not have tactics like Coq, so in order to prove theorems we need to fully construct terms with the type of the theorem
being proved. The next definitions are simple examples of proofs:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lemmaPlus1L}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{1}\;\F{+}\;\F{n}\;\equiv \;\F{suc}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{lemmaPlus1L}\;\F{n}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{lemmaMult0L}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{0}\;\F{*}\;\F{n}\;\equiv \;\F{0}{}\<[E]%
\\
\>[B]{}\F{lemmaMult0L}\;\F{n}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Proof by Rewriting}\label{rewriting}

Here is a slightly more interesting theorem:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExample}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Instead of making a completely universal claim about all numbers n and m, 
this theorem talks about a more specialized property that only holds when \ensuremath{\F{n}\;\equiv \;\F{m}}. 
The arrow symbol is pronounced ``implies.''
As before, we need to be able to reason by assuming the existence of some numbers \ensuremath{\F{n}} 
and \ensuremath{\F{m}}. We also need to assume the hypothesis \ensuremath{\F{n}\;\equiv \;\F{m}}. 

Before we show the real proof of this little theorem, we need to learn how to use 
Agda emacs mode in order to interactively construct proofs. When building a term, 
we can use holes, ?, as parts of a term that will need to be filled with a type correct term
in order to finish the definition. 
Loading the file with \ensuremath{[\mskip1.5mu \V{C-c}\;\V{C-l}\mskip1.5mu]}, we find that Agda
checks the unfinished program, turning the \ensuremath{\orange{?}} into labelled braces,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExample}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{plusIdExample}\;\F{n}\;\F{m}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
and tells us, in the information window,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{?0}\;\mathbin{:}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
that the type of the `hole' corresponds to the return type we wrote.
In order to prove this, we need to put the equality \ensuremath{\F{n}\;\equiv \;\F{m}} in context
to use it as an hypothesis. To this we can add another parameter to
\ensuremath{\F{plusIdExample}} to represent the hypothesis of type \ensuremath{\F{n}\;\equiv \;\F{m}}. 
This can be expessed as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExample}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{plusIdExample}\;\F{n}\;\F{m}\;\F{prf}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
leaving the following hole:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{?0}\;\mathbin{:}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To finish this proof we need to use the equality constructor \ensuremath{\F{refl}}, but
the hole doesn't have the shape \ensuremath{\F{x}\;\equiv \;\F{x}}. In order to make the hole type
fit the \ensuremath{\F{refl}} type, we need to \textit{pattern match} on the proof that \ensuremath{\F{n}\;\equiv \;\F{m}}.
When the pattern matches occurs, the equality \ensuremath{\F{n}\;\equiv \;\F{m}} is rewritten in the hole type,
making it equal to \ensuremath{\F{m}\;\F{+}\;\F{m}\;\equiv \;\F{m}\;\F{+}\;\F{m}} that matches \ensuremath{\F{refl}} type.

Agda mode can automate the generatiion of total pattern matching in definitions. Putting
the variable on which we want to pattern match on the hole and pressing C-c C-c.

In this proof, we want to pattern match on the equality \ensuremath{\F{n}\;\equiv \;\F{m}}, so we put the variable \ensuremath{\F{prf}}
on the hole and trigger Agda mode case spliting:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExample}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{plusIdExample}\;\F{n}\;\F{m}\;\F{prf}\;\mathrel{=}\;\{\mskip1.5mu \F{!prf!}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Emacs will change the definition of \ensuremath{\F{plusIdExample}} to:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExample}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{plusIdExample}\;\F{.m}\;\F{m}\;\F{refl}\;\mathrel{=}\;\{\mskip1.5mu \mathbin{!!}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
in which the hole has the following type
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{?0}\;\mathbin{:}\;\F{m}\;\F{+}\;\F{m}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
that matches \ensuremath{\F{refl}} type. A important part of this definition is that the left-hand side of
the definition has what we call a dotted pattern. Dotted patterns specify equality constraints
to be used by the type checker of Agda, when verifying a term. In this example, the dotted pattern
is used to specify that the first and the second argument of \ensuremath{\F{plusIdExample}} must be the same, in
order to \ensuremath{\F{refl}} be valid.

To finish the proof, we can just type \ensuremath{\F{refl}} in the hole and press C-c C-g or use Agda mode 
proof search search, by pressing C-c C-a.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExample}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{n}\;\equiv \;\F{m}\;\F{+}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{plusIdExample}\;\F{.m}\;\F{m}\;\F{refl}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[A simple equality proof]
Prove the following simple equality:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusIdExercice}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{o}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\equiv \;\F{m}\;\blue{\rightarrow}\;\F{m}\;\equiv \;\F{o}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{m}\;\equiv \;\F{m}\;\F{+}\;\F{o}{}\<[E]%
\\
\>[B]{}\F{plusIdExercice}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

Holes can be used whenever we want to skip trying to prove a theorem and just accept it as a given. 
This can be useful for developing longer proofs, since we can state subsidiary facts that we believe will be 
useful for making some larger argument, use holes to accept them on faith for the moment, 
and continue thinking about the larger argument until we are sure it makes sense; then we can 
go back and fill in the proofs we skipped. Be careful, when we leave unfinished terms we leave
a door open for total nonsense to enter Agda's nice, rigorous, formally checked world!

As another example of equality proof, consider the following simple code piece:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{mult0Plus}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;(\F{0}\;\F{+}\;\F{n})\;\F{*}\;\F{m}\;\equiv \;\F{n}\;\F{*}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{mult0Plus}\;\F{n}\;\F{m}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Agda is able to determine that \ensuremath{(\F{0}\;\F{+}\;\F{n})\;\F{*}\;\F{m}} is definitionally equal to \ensuremath{\F{n}\;\F{*}\;\F{m}}, so we can just prove
\ensuremath{\F{mult0Plus}} using \ensuremath{\F{refl}}.

\section{Proof by Case Analysis}\label{case-analysis}

Of course, not everything can be proved by simple calculation: In general, unknown, hypothetical 
values (arbitrary numbers, booleans, lists, etc.) can block the calculation. For example, if we try 
to prove the following fact using reduction as above, we get stuck.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{beqNatN+1=0}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{beqNat}\;(\F{n}\;\F{+}\;\F{1})\;\F{0}\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{beqNatN+1=0}\;\F{n}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The reason for this is that the definitions of both \ensuremath{\F{beqNat}} and \ensuremath{\F{+}} begin by performing a match on 
their first argument. But here, the first argument to \ensuremath{\F{+}} is the unknown number \ensuremath{\F{n}} and the argument 
to \ensuremath{\F{beqNat}} is the compound expression \ensuremath{\F{n}\;\F{+}\;\F{1}}; neither can be simplified.

What we need is to be able to consider the possible forms of \ensuremath{\F{n}} separately. If \ensuremath{\F{n}} is \ensuremath{\F{zero}}, then we can 
calculate the final result of \ensuremath{\F{beqNat}\;(\F{n}\;\F{+}\;\F{1})\;\F{0}} and check that it is, indeed, false. And if \ensuremath{\F{n}\;\equiv \;\F{suc}\;\F{n'}} 
for some \ensuremath{\F{n'}}, then, although we don't know exactly what number \ensuremath{\F{n}\;\F{+}\;\F{1}} yields, we can calculate that, 
at least, it will begin with one \ensuremath{\F{suc}}, and this is enough to calculate that, again, \ensuremath{\F{beqNat}\;(\F{n}\;\F{+}\;\F{1})\;\F{0}} 
will yield \ensuremath{\V{False}}.

To consider, separately, the cases where \ensuremath{\F{n}\;\equiv \;\F{0}} and where \ensuremath{\F{n}\;\equiv \;\V{S}\;\F{n'}} we can just pattern match on \ensuremath{\F{n}},
getting:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{beqNatN+1=0}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{beqNat}\;(\F{n}\;\F{+}\;\F{1})\;\F{0}\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{beqNatN+1=0}\;\F{zero}\;{}\<[21]%
\>[21]{}\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{beqNatN+1=0}\;(\F{suc}\;\F{n})\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Proofs by case analysis (pattern matching) works for any data type, like \ensuremath{\V{Bool}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{notInvolutive}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\neg \;(\neg \;\F{b})\;\equiv \;\F{b}{}\<[E]%
\\
\>[B]{}\F{notInvolutive}\;\V{False}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{notInvolutive}\;\V{True}\;{}\<[21]%
\>[21]{}\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Proof by case analysis]
Prove the following simple fact:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{zeroNBeq+1}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{beqNat}\;\F{0}\;(\F{n}\;\F{+}\;\F{1})\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{zeroNBeq+1}\;\F{n}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}


\section{More Exercices}\label{more-exercices}

Use what you have learned so far to prove the following theorems.
\begin{exe}
Prove the following:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{identityFnAppliedTwice}\;\mathbin{:}\;\mathkw{forall}\;(\F{f}\;\mathbin{:}\;\V{Bool}\;\blue{\rightarrow}\;\V{Bool}){}\<[E]%
\\
\>[B]{}\hsindent{26}{}\<[26]%
\>[26]{}(\mathkw{forall}\;(\F{b}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{f}\;\F{x}\;\equiv \;\F{x})\;\blue{\rightarrow}\;\mathkw{forall}\;(\F{b}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{f}\;(\F{f}\;\F{b})\;\equiv \;\F{b}{}\<[E]%
\\
\>[B]{}\F{identityFnAppliedTwice}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Now state and prove a theorem \ensuremath{\F{negationFnAppliedTwice}} similar to the previous one but where the second 
hypothesis says that the function f has the property that f x = not x.
\end{exe}

\begin{exe}
Prove the following lemma. (You may want to first prove a subsidiary lemma or two.)
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lemma}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\F{c}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;(\F{and}\;\F{b}\;\F{c}\;\equiv \;\F{or}\;\F{b}\;\F{c})\;\blue{\rightarrow}\;\F{b}\;\equiv \;\F{c}{}\<[E]%
\\
\>[B]{}\F{lemma}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}[Binary Numbers]
Consider a different, more efficient representation of natural numbers using a binary 
rather than unary system. That is, instead of saying that each natural number is either 
zero or the successor of a natural number, we can say that each binary number is either
zero, twice a binary number, or one more than twice a binary number.
\begin{enumerate}
  \item  First, write an inductive definition of the type bin corresponding to this description of binary numbers.
  \item  Next, write an increment function for binary numbers, and a function to convert binary numbers to unary numbers.
\end{enumerate}
\end{exe}

\chapter{Proof by Induction}\label{induction-proofs}

The next line imports all definitions from the previous chapter.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{open}\;\mathkw{import}\;\V{Basics}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
By processing this file with Agda using C-c C-l, the file \ensuremath{\V{Basics}} is loaded 
automatically.

\section{Naming Cases}

Unlike Coq, Agda does not have a way to define tactics for naming cases in
proofs by case analysis. Agda takes very seriously the Curry-Howard isomorphism
in which case analysis is understood as pattern matching in function definitions.
Consider the following example, that show a property of \ensuremath{\F{and}} function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{andElim1}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\F{c}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{and}\;\F{b}\;\F{c}\;\equiv \;\V{True}\;\blue{\rightarrow}\;\F{b}\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{andElim1}\;\F{b}\;\F{c}\;\F{prf}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can prove this by case analysis on \ensuremath{\F{b}}, since and is defined by analysis
on the first argument (see Section \ref{booleans}). So, we put \ensuremath{\F{b}} on the hole 
and trigger the case analysis using Agda mode to produce the following:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{andElim1}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\F{c}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{and}\;\F{b}\;\F{c}\;\equiv \;\V{True}\;\blue{\rightarrow}\;\F{b}\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{andElim1}\;\V{True}\;\F{c}\;{}\<[18]%
\>[18]{}\F{prf}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\
\>[B]{}\F{andElim1}\;\V{False}\;\F{c}\;\F{prf}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{1}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now, Agda type checker is able to reduce the hypothesis \ensuremath{\F{prf}} and
the goals hold definitionally using \ensuremath{\F{refl}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{andElim1}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\F{c}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{and}\;\F{b}\;\F{c}\;\equiv \;\V{True}\;\blue{\rightarrow}\;\F{b}\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{andElim1}\;\V{True}\;\F{c}\;{}\<[18]%
\>[18]{}\F{prf}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{andElim1}\;\V{False}\;\F{c}\;\F{prf}\;\mathrel{=}\;\F{prf}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Simple case analysis proof.]
Prove \ensuremath{\F{andElim2}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{andElim2}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\F{c}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{and}\;\F{b}\;\F{c}\;\equiv \;\V{True}\;\blue{\rightarrow}\;\F{c}\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{andElim2}\;\F{b}\;\F{c}\;\F{prf}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\section{Proof by Induction}\label{proof-by-induction}

We proved in the last chapter that 0 is a neutral element for + on the left using a simple argument. 
The fact that it is also a neutral element on the right...

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plus0R}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{0}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\F{plus0R}\;\F{n}\;\mathrel{=}\;\F{refl}\mbox{\onelinecomment  does not type check!}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

... cannot be proved in the same simple way. Just using \ensuremath{\F{refl}} doesn't work: the n in n + 0 is an arbitrary unknown number, 
so Agda cannot reduce the definition of + can't be simplified for check that \ensuremath{\F{n}\;\F{+}\;\F{0}\;\equiv \;\F{n}}.

And reasoning by cases doesn't get us much further: the branch of the case analysis where we assume n = 0 goes through, 
but in the branch where \ensuremath{\F{n}\;\mathrel{=}\;\V{S}\;\F{n'}} for some \ensuremath{\F{n'}} we get stuck in exactly the same way. We could pattern match on \ensuremath{\F{n'}} to 
get one step further, but since \ensuremath{\F{n}} can be arbitrarily large, if we try to keep on like this we'll never be done.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plus0R}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{0}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\F{plus0R}\;\F{zero}\;{}\<[16]%
\>[16]{}\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{plus0R}\;(\F{suc}\;\F{n'})\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}\mbox{\onelinecomment  stuck here...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

To prove such facts --- indeed, to prove most interesting facts about numbers, lists, and other inductively defined sets 
--- we need a more powerful reasoning principle: \textbf{induction}.

Recall (from high school) the principle of induction over natural numbers: If \ensuremath{\V{P}\;(\F{n})} is some proposition involving a natural 
number \ensuremath{\F{n}} and we want to show that \ensuremath{\V{P}} holds for all numbers \ensuremath{\F{n}}, we can reason like this:
\begin{itemize}
  \item show that \ensuremath{\V{P}\;(\F{zero})} holds;
  \item show that, for any \ensuremath{\F{n'}}, if \ensuremath{\V{P}\;(\F{n'})} holds, then so does \ensuremath{\V{P}\;(\F{suc}\;\F{n'})};
        conclude that \ensuremath{\V{P}\;(\F{n})} holds for all \ensuremath{\F{n}}.
\end{itemize}

Note that the induction hypothesis can be seen as a ``recursive call'' of the property being proved over \ensuremath{\F{n'}}. Taking this
view, induction proofs are just recursive functions! Curry-Howard isomorphism, strikes again! We need to use the induction
hypothesis \ensuremath{\F{plus0R}\;\F{n'}}, which has type \ensuremath{\F{n'}\;\F{+}\;\F{0}\;\equiv \;\F{n'}}, but the hole has type \ensuremath{\F{?0}\;\mathbin{:}\;(\F{suc}\;\F{n'}\;\F{+}\;\F{0})\;\equiv \;\F{suc}\;\F{n'}}, that can be simplified
by Agda to \ensuremath{\F{?0}\;\mathbin{:}\;\F{suc}\;(\F{n'}\;\F{+}\;\F{0})\;\equiv \;\F{suc}\;\F{n'}}, according to the definition of \ensuremath{\F{+}}. Note that, that only difference between the type
\ensuremath{\F{suc}\;(\F{n'}\;\F{+}\;\F{0})\;\equiv \;\F{suc}\;\F{n'}} and the type of induction hypothesis \ensuremath{\F{n'}\;\F{+}\;\F{0}\;\equiv \;\F{n'}} is the application of \ensuremath{\F{suc}} constructor in both sides
of the equality, showing a \textit{congruence} property. Function \ensuremath{\F{cong}} allows us to reason in this way by applying a function on
both sides of a given equality. For now, we will only use \ensuremath{\F{cong}} and other equality related functions as ``black-boxes''. Latter,
we will see how these are defined in Agda.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plus0R}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{0}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\F{plus0R}\;\F{zero}\;{}\<[17]%
\>[17]{}\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{plus0R}\;(\F{suc}\;\F{n'})\;\mathrel{=}\;\F{cong}\;\F{suc}\;(\F{plus0R}\;\F{n'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As another example of an inductive proof over natural numbers, consider the following theorem:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{minusDiag}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{-}\;\F{n}\;\equiv \;\F{0}{}\<[E]%
\\
\>[B]{}\F{minusDiag}\;\F{zero}\;{}\<[20]%
\>[20]{}\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{minusDiag}\;(\F{suc}\;\F{n'})\;\mathrel{=}\;\F{minusDiag}\;\F{n'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Simple induction proofs]
Prove the following lemmas using induction. You might need previously proven results.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{mult0R}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{*}\;\F{0}\;\equiv \;\F{0}{}\<[E]%
\\
\>[B]{}\F{mult0R}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{plusNSucM}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{suc}\;(\F{n}\;\F{+}\;\F{m})\;\equiv \;\F{n}\;\F{+}\;\F{suc}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{plusNSucM}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{1}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{plusComm}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{m}\;\equiv \;\F{m}\;\F{+}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{plusComm}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{2}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{plusAssoc}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{p}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{+}\;(\F{m}\;\F{+}\;\F{p})\;\equiv \;(\F{n}\;\F{+}\;\F{m})\;\F{+}\;\F{p}{}\<[E]%
\\
\>[B]{}\F{plusAssoc}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{3}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}{doublePlus}
Consider the following function, which doubles its argument:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{double}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{double}\;\F{zero}\;\mathrel{=}\;\F{zero}{}\<[E]%
\\
\>[B]{}\F{double}\;(\F{suc}\;\F{n'})\;\mathrel{=}\;\F{suc}\;(\F{suc}\;(\F{double}\;\F{n'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Use induction to prove this simple fact about double:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{doublePlus}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{double}\;\F{n}\;\equiv \;\F{n}\;\F{+}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{doublePlus}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\section{Proofs within Proofs}\label{proofs-within-proofs}

In informal mathematics, large proofs are very often broken into a sequence of theorems, 
with later proofs referring to earlier theorems. Occasionally, however, a proof will need some 
miscellaneous fact that is too trivial (and of too little general interest) to bother giving it its 
own top-level name. In such cases, it is convenient to be able to simply state and prove the needed ``sub-theorem'' 
right at the point where it is used. In Agda, we can do this by simply stating this little theorem as a
local definition using \ensuremath{\mathkw{where}} reserved word. For people used to Haskell, local definitions are just as in Haskell.
In fact, Agda syntax is heavily based on Haskell's. Next example shows how to use local definitions in a proof.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{mult0Plus'}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;(\F{0}\;\F{+}\;\F{n})\;\F{*}\;\F{m}\;\equiv \;\F{n}\;\F{*}\;\F{m}{}\<[E]%
\\
\>[B]{}\F{mult0Plus'}\;\F{n}\;\F{m}\;\mathrel{=}\;\F{cong}\;(\F{\char92 n}\;\blue{\rightarrow}\;\F{n}\;\F{*}\;\F{m})\;\F{h}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\F{h}\;\mathbin{:}\;\F{0}\;\F{+}\;\F{n}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\F{h}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Here we use \ensuremath{\F{h}} as a sub-proof of the fact \ensuremath{\F{0}\;\F{+}\;\F{n}\;\equiv \;\F{n}} and a anonymous function --- denoted by the \ --- to represent
the greek letter $\lambda$, that is used in $\lambda$-calculus to represent a function binding symbol.

The next is a more elaborate example of local definitions in proofs. Note that we need to make a local proof
of the fact that \ensuremath{\F{n}\;\F{+}\;\F{m}\;\equiv \;\F{m}\;\F{+}\;\F{n}}, using the previous fact (proved in an exercice) that addition is commutative.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusRearrange}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{p}\;\F{q}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;(\F{n}\;\F{+}\;\F{m})\;\F{+}\;(\F{p}\;\F{+}\;\F{q})\;\equiv \;(\F{m}\;\F{+}\;\F{n})\;\F{+}\;(\F{p}\;\F{+}\;\F{q}){}\<[E]%
\\
\>[B]{}\F{plusRearrange}\;\F{n}\;\F{m}\;\F{p}\;\F{q}\;\mathrel{=}\;\F{cong}\;(\F{\char92 n}\;\blue{\rightarrow}\;\F{n}\;\F{+}\;\F{p}\;\F{+}\;\F{q})\;\F{nmComm}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{15}{}\<[15]%
\>[15]{}\F{nmComm}\;\mathbin{:}\;\F{n}\;\F{+}\;\F{m}\;\equiv \;\F{m}\;\F{+}\;\F{n}{}\<[E]%
\\
\>[B]{}\hsindent{15}{}\<[15]%
\>[15]{}\F{nmComm}\;\mathrel{=}\;\F{plusComm}\;\F{n}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Commutativity of Multiplication]
Use local definitions to help prove this theorem. You shouldn't need to use induction.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{plusSwap}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{p}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{+}\;(\F{m}\;\F{+}\;\F{p})\;\equiv \;\F{m}\;\F{+}\;(\F{n}\;\F{+}\;\F{p}){}\<[E]%
\\
\>[B]{}\F{plusSwap}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Now prove commutativity of multiplication. (You will probably need to define and prove a 
separate subsidiary theorem to be used in the proof of this one.) You may find that 
\ensuremath{\F{plusSwap}} comes in handy.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{multComm}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{*}\;\F{m}\;\equiv \;\F{m}\;\F{*}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{multComm}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}[even \ensuremath{\F{n}} implies odd \ensuremath{\F{suc}\;\F{n}}]
Prove the following simple fact:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{evenNoddSucN}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{evenb}\;\F{n}\;\equiv \;\neg \;(\F{oddb}\;(\F{suc}\;\F{n})){}\<[E]%
\\
\>[B]{}\F{evenNoddSucN}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\section{More Exercices}

\begin{exe}
Take a piece of paper. For each of the following theorems, first think about whether (a) 
it can be proved using only simplification and rewriting, (b) it also requires case analysis, 
or (c) it also requires induction. Write down your prediction. Then fill in the proof. 
(There is no need to turn in your piece of paper; this is just to encourage you to reflect before hacking!)

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{bleNatRefl}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\V{True}\;\equiv \;\F{bleNat}\;\F{n}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{bleNatRefl}\;\mathrel{=}\;{}\<[15]%
\>[15]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{zeroNbeqSuc}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{beqNat}\;\F{0}\;(\F{suc}\;\F{n})\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{zeroNbeqSuc}\;\mathrel{=}\;{}\<[16]%
\>[16]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{1}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{andFalseR}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{and}\;\F{b}\;\V{False}\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{andFalseR}\;\mathrel{=}\;{}\<[14]%
\>[14]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{2}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{plusBleCompatL}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{p}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{bleNat}\;\F{n}\;\F{m}\;\equiv \;\V{True}\;\blue{\rightarrow}{}\<[E]%
\\
\>[B]{}\hsindent{18}{}\<[18]%
\>[18]{}\F{bleNat}\;(\F{p}\;\F{+}\;\F{n})\;(\F{p}\;\F{+}\;\F{m})\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{plusBleCompatL}\;\mathrel{=}\;{}\<[19]%
\>[19]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{3}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{sucNBeq0}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{beqNat}\;(\F{suc}\;\F{n})\;\F{zero}\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{sucNBeq0}\;\mathrel{=}\;{}\<[13]%
\>[13]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{4}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{mult1L}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{1}\;\F{*}\;\F{n}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\F{mult1L}\;\mathrel{=}\;{}\<[11]%
\>[11]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{5}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{all3Spec}\;\mathbin{:}\;\mathkw{forall}\;(\F{b}\;\F{c}\;\mathbin{:}\;\V{Bool})\;\blue{\rightarrow}\;\F{or}\;(\F{and}\;\F{b}\;\F{c})\;(\F{or}\;(\neg \;\F{b})\;(\neg \;\F{c}))\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{all3Spec}\;\mathrel{=}\;{}\<[13]%
\>[13]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{6}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{multPlusDistrR}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{p}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;(\F{n}\;\F{+}\;\F{m})\;\F{*}\;\F{p}\;\equiv \;(\F{n}\;\F{*}\;\F{p})\;\F{+}\;(\F{m}\;\F{*}\;\F{p}){}\<[E]%
\\
\>[B]{}\F{multPlusDistrR}\;\mathrel{=}\;{}\<[19]%
\>[19]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{7}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{multAssoc}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\F{p}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\F{n}\;\F{*}\;(\F{m}\;\F{*}\;\F{p})\;\equiv \;(\F{n}\;\F{*}\;\F{m})\;\F{*}\;\F{p}{}\<[E]%
\\
\>[B]{}\F{multAssoc}\;\mathrel{=}\;{}\<[14]%
\>[14]{}\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{8}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{beqNatRefl}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\V{True}\;\equiv \;\F{beqNat}\;\F{n}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{beqNatRefl}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{9}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\section{Equational Reasoning}\label{equational-reasoning}

Agda's supports for mixfix operators offers an excellent oportunity for creating
operators that can resamble pencil-and-paper style of reasoning. In this section
we will see how to use support for equational reasoning to construct a proof for
commutativity of addition for natural numbers.

NOTE: I belive that here would be nice to talk a bit about the usage of equational
reasoning proofs. Latter, in another chapter, talk about propositional equality and
some functions over it.

\chapter{Lists --- Working with Structured Data}\label{lists}

\section{Pairs of Numbers}

In a data type definition, each constructor can take any number of arguments ---
 none (as with \ensuremath{\V{True}} and \ensuremath{\F{zero}}), one (as with \ensuremath{\F{suc}}), or more than one, as in this definition:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\V{NatProd}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\anonymous ,\anonymous \;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{NatProd}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This declaration can be read: ``There is just one way to construct a pair of numbers: by applying 
the constructor \ensuremath{,} to two arguments of type \ensuremath{\V{Nat}}.''

Here are two simple function definitions for extracting the first and second components of a pair. 
(The definitions also illustrate how to do pattern matching on two-argument constructors.)

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{fst}\;\mathbin{:}\;\V{NatProd}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{fst}\;(\F{n},\anonymous )\;\mathrel{=}\;\F{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{snd}\;\mathbin{:}\;\V{NatProd}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{snd}\;(\anonymous ,\F{n})\;\mathrel{=}\;\F{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\V{NatProd}} ilustrates that, in Agda, we can define infix constructors naturally by marking 
argument positions with underscores.

Let's try and prove a few simple facts about pairs. If we state the lemmas in a particular 
(and slightly peculiar) way, we can prove them with just \ensuremath{\F{refl}} (and its built-in simplification):

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{surjectivePairing}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{m}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;(\F{n},\F{m})\;\equiv \;(\F{fst}\;(\F{n},\F{m}),\F{snd}\;(\F{n},\F{m})){}\<[E]%
\\
\>[B]{}\F{surjectivePairing}\;\F{n}\;\F{m}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Another way to state and prove this simple lemma is using pattern matching (case analysis):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{surjectivePairing'}\;\mathbin{:}\;\mathkw{forall}\;(\F{p}\;\mathbin{:}\;\V{NatProd})\;\blue{\rightarrow}\;\F{p}\;\equiv \;(\F{fst}\;\F{p},\F{snd}\;\F{p}){}\<[E]%
\\
\>[B]{}\F{surjectivePairing'}\;(\F{n},\F{m})\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Here, in order to be able to state the definitional equality between \ensuremath{\F{p}} and  \ensuremath{(\F{fst}\;\F{p},\F{snd}\;\F{p})} we
need to pattern match on \ensuremath{\F{p}} in order to Agda be able to reduce functions \ensuremath{\F{fst}} and \ensuremath{\F{snd}}.

\begin{exe}[Projections and Swap]
First, define a function \ensuremath{\F{swap}} which swaps the first and second element of a given pair:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{swap}\;\mathbin{:}\;\V{NatProd}\;\blue{\rightarrow}\;\V{NatProd}{}\<[E]%
\\
\>[B]{}\F{swap}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Next prove this property:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{fstSndSwap}\;\mathbin{:}\;\mathkw{forall}\;(\F{p}\;\mathbin{:}\;\V{NatProd})\;\blue{\rightarrow}\;(\F{snd}\;\F{p},\F{fst}\;\F{p})\;\equiv \;\F{swap}\;\F{p}{}\<[E]%
\\
\>[B]{}\F{fstSndSwap}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\section{List of Numbers}\label{list-of-numbers}

Generalizing the definition of pairs a little, we can describe the type of lists of numbers 
like this: ``A list is either the empty list or else a pair of a number and another list.''

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\V{NList}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\D{nil}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\V{NList}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\anonymous ,\anonymous \;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathkw{infixr}\;\F{4}\;\anonymous ,\anonymous {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As an example, here we have a simple 3-element list:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{sample}\;\mathbin{:}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{sample}\;\mathrel{=}\;\F{1},\F{2},\F{3},\D{nil}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As you might be an alert reader, Agda supports overloading of data constructors. The context
of a given expression is used to determine of which we are considering.

A number of functions are useful for manipulating lists. For example, the \ensuremath{\F{repeat}} function 
takes a number \ensuremath{\F{n}} and a \ensuremath{\F{count}} and returns a list of length \ensuremath{\F{count}} where every element is \ensuremath{\F{n}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{repeat}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Nat}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{repeat}\;\F{n}\;\F{zero}\;\mathrel{=}\;\D{nil}{}\<[E]%
\\
\>[B]{}\F{repeat}\;\F{n}\;(\F{suc}\;\F{m})\;\mathrel{=}\;\F{n},\F{repeat}\;\F{n}\;\F{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\F{length}} function calculates the number of elements of a given list.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{length}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{length}\;\D{nil}\;\mathrel{=}\;\F{zero}{}\<[E]%
\\
\>[B]{}\F{length}\;(\F{x},\F{xs})\;\mathrel{=}\;\F{suc}\;(\F{length}\;\F{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\F{++}} (``append'') function concatenate two lists:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{infixr}\;\F{4}\;\F{\char95 ++\char95 }{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{\char95 ++\char95 }\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\D{nil}\;\F{++}\;\F{ys}\;\mathrel{=}\;\F{ys}{}\<[E]%
\\
\>[B]{}(\F{x},\F{xs})\;\F{++}\;\F{ys}\;\mathrel{=}\;\F{x},(\F{xs}\;\F{++}\;\F{ys}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Here are two smaller examples of programming with lists. The \ensuremath{\F{head}} function returns 
the first element (the ``head'') of the list, while \ensuremath{\F{tail}} returns everything but the 
first element (the ``tail''). Of course, the empty list has no first element, so 
we must pass a default value to be returned in that case.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{head}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;(\F{default}\;\mathbin{:}\;\V{Nat})\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{head}\;\D{nil}\;{}\<[14]%
\>[14]{}\F{d}\;\mathrel{=}\;\F{d}{}\<[E]%
\\
\>[B]{}\F{head}\;(\F{x},\anonymous )\;\F{d}\;\mathrel{=}\;\F{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{tail}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{tail}\;\D{nil}\;{}\<[15]%
\>[15]{}\mathrel{=}\;\D{nil}{}\<[E]%
\\
\>[B]{}\F{tail}\;(\anonymous ,\F{xs})\;\mathrel{=}\;\F{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Definition of \ensuremath{\F{nonZeros}}]
Define the function \ensuremath{\F{nonZeros}} that remove all \ensuremath{\F{zero}} values from a \ensuremath{\V{NList}}. Implement your function
in such a way that \ensuremath{\F{testNonZeros}} be a type correct term.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{nonZeros}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{nonZeros}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testNonZeros}\;\mathbin{:}\;(\F{0},\F{1},\F{0},\F{2},\F{0},\D{nil})\;\equiv \;(\F{1},\F{2},\D{nil}){}\<[E]%
\\
\>[B]{}\F{testNonZeros}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}[Definition of \ensuremath{\F{oddMembers}}]
Define the function \ensuremath{\F{oddMembers}} that remove all even values from a \ensuremath{\V{NList}}. Implement your function
in such a way that \ensuremath{\F{testOddMembers}} be a type correct term.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{oddMembers}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{oddMembers}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testOddMembers}\;\mathbin{:}\;(\F{0},\F{1},\F{0},\F{3},\F{0},\D{nil})\;\equiv \;(\F{1},\F{3},\D{nil}){}\<[E]%
\\
\>[B]{}\F{testOddMembers}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}[Definition of \ensuremath{\F{alternate}}]
Implement \ensuremath{\F{alternate}} that alternates two given \ensuremath{\V{NLists}} into one.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{alternate}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{alternate}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}


\section{Bag via Lists}

A bag (or multiset) is like a set, but each element can appear multiple times instead of just once. 
One reasonable implementation of bags is to represent a bag of numbers as a list.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\V{Bag}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\V{Bag}\;\mathrel{=}\;\V{NList}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note that \ensuremath{\V{Bag}} is explicitly annotated with type \ensuremath{\D{Set}}, that is the type of ``types''.
\begin{exe}[Functions over bags]
Complete the following definitions for the functions \ensuremath{\F{count}}, \ensuremath{\F{sum}}, \ensuremath{\F{add}}, and \ensuremath{\F{member}} for bags.
Again, implement your functions in a way that the test cases are typeable by Agda.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{count}\;\mathbin{:}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bag}{}\<[E]%
\\
\>[B]{}\F{count}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testCount1}\;\mathbin{:}\;\F{count}\;\F{1}\;(\F{1},\F{2},\F{1},\D{nil})\;\equiv \;\F{2}{}\<[E]%
\\
\>[B]{}\F{testCount1}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testCount2}\;\mathbin{:}\;\F{count}\;\F{3}\;(\F{1},\F{2},\F{1},\D{nil})\;\equiv \;\F{0}{}\<[E]%
\\
\>[B]{}\F{testCount2}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{sum}\;\mathbin{:}\;\V{Bag}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{sum}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testSum}\;\mathbin{:}\;\F{sum}\;(\F{1},\F{2},\F{1},\D{nil})\;\equiv \;\F{6}{}\<[E]%
\\
\>[B]{}\F{testSum}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{add}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bag}{}\<[E]%
\\
\>[B]{}\F{add}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testAdd}\;\mathbin{:}\;\F{count}\;\F{1}\;(\F{add}\;\F{1}\;(\F{1},\F{2},\F{1},\D{nil}))\;\equiv \;\F{3}{}\<[E]%
\\
\>[B]{}\F{testAdd}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{member}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{member}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testMember1}\;\mathbin{:}\;\F{member}\;\F{1}\;(\F{1},\F{2},\F{1},\D{nil})\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{testMember1}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testMember2}\;\mathbin{:}\;\F{member}\;\F{3}\;(\F{1},\F{2},\F{1},\D{nil})\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{testMember2}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}[More \ensuremath{\F{bag}} functions]
Here are some more bag functions for you to practice with.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{removeOne}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bag}{}\<[E]%
\\
\>[B]{}\F{removeOne}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testRemoveOne1}\;\mathbin{:}\;\F{count}\;\F{1}\;(\F{removeOne}\;\F{1}\;(\F{1},\F{2},\F{1},\D{nil}))\;\equiv \;\F{1}{}\<[E]%
\\
\>[B]{}\F{testRemoveOne1}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testRemoveOne2}\;\mathbin{:}\;\F{count}\;\F{1}\;(\F{removeOne}\;\F{1}\;(\F{1},\F{2},\F{1},\D{nil}))\;\equiv \;\F{2}{}\<[E]%
\\
\>[B]{}\F{testRemoveOne2}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{removeAll}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bag}{}\<[E]%
\\
\>[B]{}\F{removeAll}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testRemoveAll}\;\mathbin{:}\;\F{count}\;\F{1}\;(\F{removeAll}\;\F{1}\;(\F{1},\F{2},\F{1},\D{nil}))\;\equiv \;\F{0}{}\<[E]%
\\
\>[B]{}\F{testRemoveAll}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{subset}\;\mathbin{:}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bag}\;\blue{\rightarrow}\;\V{Bool}{}\<[E]%
\\
\>[B]{}\F{subset}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testSubset1}\;\mathbin{:}\;\F{subset}\;(\F{1},\F{2},\D{nil})\;(\F{3},\F{1},\F{2},\D{nil})\;\equiv \;\V{True}{}\<[E]%
\\
\>[B]{}\F{testSubset1}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{testSubset2}\;\mathbin{:}\;\F{subset}\;(\F{2},\F{3},\D{nil})\;(\F{1},\F{2},\F{4},\D{nil})\;\equiv \;\V{False}{}\<[E]%
\\
\>[B]{}\F{testSubset2}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}

\begin{exe}
Write down an interesting theorem about bags involving the functions \ensuremath{\F{count}} and \ensuremath{\F{add}}, 
and prove it. Note that, since this problem is somewhat open-ended, it's possible that 
you may come up with a theorem which is true, but whose proof requires techniques you 
haven't learned yet. Feel free to ask for help if you get stuck!
\end{exe}

\section{Reasoning about Lists}

Just as with numbers, simple facts about list-processing functions can sometimes be 
proved entirely by simplification. For example, the simplification performed by \ensuremath{\F{refl}} 
is enough for this theorem...
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{nilAppL}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\D{nil}\;\F{++}\;\F{n}\;\equiv \;\F{n}{}\<[E]%
\\
\>[B]{}\F{nilAppL}\;\F{n}\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
... because the \ensuremath{\D{nil}} is substituted into the match position in the definition of \ensuremath{\F{++}}, 
allowing the match itself to be simplified.

Also, as with numbers, it is sometimes helpful to perform case analysis on the 
possible shapes (empty or non-empty) of an unknown list, as shown in this little theorem:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{tailLengthPred}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{pred}\;(\F{length}\;\F{n})\;\equiv \;\F{length}\;(\F{tail}\;\F{n}){}\<[E]%
\\
\>[B]{}\F{tailLengthPred}\;\D{nil}\;{}\<[24]%
\>[24]{}\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{tailLengthPred}\;(\F{x},\F{n})\;\mathrel{=}\;\F{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Usually, though, interesting theorems about lists require induction for their proofs.

\subsection{Micro-sermon}

Simply reading example proofs will not get you very far! It is very important to work 
through the details of each one, using Agda and thinking about what each step of the 
proof achieves. Otherwise it is more or less guaranteed that the exercises will make no sense.

\subsection{Induction on Lists}

Proofs by induction over datatypes like \ensuremath{\V{NList}} are perhaps a little less familiar than standard 
natural number induction, but the basic idea is equally simple. Each data type declaration defines 
a set of data values that can be built up from the declared constructors: a boolean can be either 
\ensuremath{\V{True}} or \ensuremath{\V{False}}; a number can be either \ensuremath{\F{zero}} or \ensuremath{\F{suc}} applied to a number; a list can be 
either \ensuremath{\D{nil}} or \ensuremath{,} applied to a number and a list.

Moreover, applications of the declared constructors to one another are the only possible shapes that 
elements of a inductively defined set can have, and this fact directly gives rise to a way of reasoning 
about inductively defined sets: a number is either \ensuremath{\F{zero}} or else it is \ensuremath{\F{suc}} applied to some smaller number; a list 
is either \ensuremath{\D{nil}} or else it is \ensuremath{,} applied to some number and some smaller list; etc. So, if we have in mind 
some proposition \ensuremath{\V{P}} that mentions a list \ensuremath{\F{l}} and we want to argue that \ensuremath{\V{P}} holds for all lists, we can reason as follows:
\begin{itemize}
  \item First, show that \ensuremath{\V{P}} is true of \ensuremath{\F{l}} when \ensuremath{\F{l}} is \ensuremath{\D{nil}}.
  \item Then show that \ensuremath{\V{P}} is true of \ensuremath{\F{l}} when \ensuremath{\F{l}} is \ensuremath{\F{n},\F{l'}} for some number \ensuremath{\F{n}} and some smaller list \ensuremath{\F{l'}}, assuming that 
        \ensuremath{\V{P}} is true for \ensuremath{\F{l'}}.
\end{itemize}
Since larger lists can only be built up from smaller ones, eventually reaching \ensuremath{\D{nil}}, these two things 
together establish the truth of \ensuremath{\V{P}} for all lists \ensuremath{\F{l}}. Here's a concrete example:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{appAssoc}\;\mathbin{:}\;\mathkw{forall}\;(\F{l1}\;\F{l2}\;\F{l3}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{l1}\;\F{++}\;(\F{l2}\;\F{++}\;\F{l3})\;\equiv \;(\F{l1}\;\F{++}\;\F{l2})\;\F{++}\;\F{l3}{}\<[E]%
\\
\>[B]{}\F{appAssoc}\;\D{nil}\;\F{l2}\;\F{l3}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{appAssoc}\;(\F{x},\F{l1})\;\F{l2}\;\F{l3}\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}((\F{x},\F{l1})\;\F{++}\;(\F{l2}\;\F{++}\;\F{l3}))\;\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\F{x},(\F{l1}\;\F{++}\;(\F{l2}\;\F{++}\;\F{l3})))\;\equiv \;[\mskip1.5mu \F{cong}\;(\F{\char92 p}\;\blue{\rightarrow}\;\F{x},\F{p})\;(\F{appAssoc}\;\F{l1}\;\F{l2}\;\F{l3})\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\F{x},((\F{l1}\;\F{++}\;\F{l2})\;\F{++}\;\F{l3}))\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\D{\Box}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Here we use Agda infix operators to do some equational reasoning in proofs, that allow us to argue in a 
pencil and paper fashion. The operator \ensuremath{\equiv \;[\mskip1.5mu \orange{?}\mskip1.5mu]} acts like a
equality that uses the term between brackets to rewrite the current term and \ensuremath{\D{\Box}} finish the proof.

The same proof can be done in the following way, in a paper:

\begin{theorem}
For all \ensuremath{\V{NList}}s \ensuremath{\F{l1}}, \ensuremath{\F{l2}} and \ensuremath{\F{l3}}, we have \ensuremath{\F{l1}\;\F{++}\;(\F{l2}\;\F{++}\;\F{l3})\;\equiv \;(\F{l1}\;\F{++}\;\F{l2})\;\F{++}\;\F{l3}}.
\end{theorem}
\begin{proof}
We will proceed by induction on \ensuremath{\F{l1}}.
\begin{enumerate}
  \item Case \ensuremath{\F{l1}\;\mathrel{=}\;\D{nil}}: In this case we have: \ensuremath{\D{nil}} $\ensuremath{\F{++}} (l2 \ensuremath{\F{++}} l3) \equiv l2 \ensuremath{\F{++}} l3 \equiv$ $($\ensuremath{\D{nil}} $\ensuremath{\F{++}} l2) \ensuremath{\F{++}} l3$, as required.
  \item Case \ensuremath{\F{l1}\;\mathrel{=}\;\F{x},\F{l1'}}: We have that:
  \begin{center}
  \begin{tabular}{lcl}
    (x , l1') ++ (l2 ++ l3) & $\equiv$ & \{by def.\}\\
    x , (l1' ++ (l2 ++ l3)) & $\equiv$ & \{by I.H.\}\\
    x , ((l1' ++ l2) ++ l3  & $\equiv$ & \{by def.\}\\
    ((x , l1') ++ l2) ++ l3 & $\Box$  
  \end{tabular}
  \end{center}
  as required.
\end{enumerate}
\end{proof}

Here's another simple example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{appLength}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\F{n'}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{length}\;(\F{n}\;\F{++}\;\F{n'})\;\equiv \;\F{length}\;\F{n}\;\F{+}\;\F{length}\;\F{n'}{}\<[E]%
\\
\>[B]{}\F{appLength}\;\D{nil}\;\F{n'}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{appLength}\;(\F{x},\F{xs})\;\F{n'}\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\F{length}\;((\F{x},\F{xs})\;\F{++}\;\F{n'})\;{}\<[33]%
\>[33]{}\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\F{length}\;(\F{x},(\F{xs}\;\F{++}\;\F{n'}))\;{}\<[33]%
\>[33]{}\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\F{suc}\;(\F{length}\;(\F{xs}\;\F{++}\;\F{n'}))\;{}\<[33]%
\>[33]{}\equiv \;[\mskip1.5mu \F{cong}\;\F{suc}\;(\F{appLength}\;\F{xs}\;\F{n'})\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\F{suc}\;(\F{length}\;\F{xs}\;\F{+}\;\F{length}\;\F{n'})\;\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\F{length}\;(\F{x},\F{xs})\;\F{+}\;\F{length}\;\F{n'}\;{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\D{\Box}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Practice informal proof]
Prove \ensuremath{\F{appLength}} theorem using a informal style, like the proof for \ensuremath{\F{appAssoc}}.
\end{exe}

For a slightly more involved example of an inductive proof over lists, suppose we define a 
``cons on the right'' function snoc like this...

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{snoc}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{snoc}\;\F{n}\;\D{nil}\;\mathrel{=}\;\F{n},\D{nil}{}\<[E]%
\\
\>[B]{}\F{snoc}\;\F{n}\;(\F{x},\F{xs})\;\mathrel{=}\;\F{x},(\F{snoc}\;\F{n}\;\F{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

... and use it to define a list-reversing function \ensuremath{\F{rev}} like this:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{rev}\;\mathbin{:}\;\V{NList}\;\blue{\rightarrow}\;\V{NList}{}\<[E]%
\\
\>[B]{}\F{rev}\;\D{nil}\;\mathrel{=}\;\D{nil}{}\<[E]%
\\
\>[B]{}\F{rev}\;(\F{x},\F{xs})\;\mathrel{=}\;\F{snoc}\;\F{x}\;(\F{rev}\;\F{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now let's prove some more list theorems using our newly defined snoc and rev. For something a 
little more challenging than the inductive proofs we've seen so far, let's prove that 
reversing a list does not change its length. Our first attempt at this proof gets stuck in the successor case...

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{revLength}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{length}\;(\F{rev}\;\F{n})\;\equiv \;\F{length}\;\F{n}{}\<[E]%
\\
\>[B]{}\F{revLength}\;\D{nil}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{revLength}\;(\F{x},\F{xs})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{rev}\;(\F{x},\F{xs}))\;\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{snoc}\;\F{x}\;(\F{rev}\;\F{xs}))\;\equiv \;[\mskip1.5mu \{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{suc}\;(\F{length}\;(\F{rev}\;\F{xs}))\;{}\<[32]%
\>[32]{}\equiv \;[\mskip1.5mu \{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{1}}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{suc}\;(\F{length}\;\F{xs})\;{}\<[32]%
\>[32]{}\equiv \;[\mskip1.5mu \{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{2}}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{x},\F{xs})\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\D{\Box}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

So let's take the equation about snoc that would have enabled us to make progress and prove it as a separate lemma.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lengthSnoc}\;\mathbin{:}\;\mathkw{forall}\;(\F{n}\;\mathbin{:}\;\V{Nat})\;(\F{l}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{length}\;(\F{snoc}\;\F{n}\;\F{l})\;\equiv \;\F{suc}\;(\F{length}\;\F{l}){}\<[E]%
\\
\>[B]{}\F{lengthSnoc}\;\F{n}\;\D{nil}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{lengthSnoc}\;\F{n}\;(\F{x},\F{xs})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{snoc}\;\F{n}\;(\F{x},\F{xs}))\;\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{x},(\F{snoc}\;\F{n}\;\F{xs}))\;\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{suc}\;(\F{length}\;(\F{snoc}\;\F{n}\;\F{xs}))\;\equiv \;[\mskip1.5mu \F{cong}\;\F{suc}\;(\F{lengthSnoc}\;\F{n}\;\F{xs})\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{suc}\;(\F{length}\;(\F{x},\F{xs}))\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\D{\Box}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that we make the lemma as general as possible: in particular, we quantify over all natlists, not just those 
that result from an application of \ensuremath{\F{rev}}. This should seem natural, because the truth of the goal clearly doesn't 
depend on the list having been reversed. Moreover, it is much easier to prove the more general property.

Now we can complete the original proof.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{revLength}\;\mathbin{:}\;\mathkw{forall}\;(\F{l}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{length}\;(\F{rev}\;\F{l})\;\equiv \;\F{length}\;\F{l}{}\<[E]%
\\
\>[B]{}\F{revLength}\;\D{nil}\;\mathrel{=}\;\F{refl}{}\<[E]%
\\
\>[B]{}\F{revLength}\;(\F{x},\F{xs})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{rev}\;(\F{x},\F{xs}))\;{}\<[32]%
\>[32]{}\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{snoc}\;\F{x}\;(\F{rev}\;\F{xs}))\;\equiv \;[\mskip1.5mu \F{lengthSnoc}\;\F{x}\;(\F{rev}\;\F{xs})\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{suc}\;(\F{length}\;(\F{rev}\;\F{xs}))\;{}\<[32]%
\>[32]{}\equiv \;[\mskip1.5mu \F{cong}\;\F{suc}\;(\F{revLength}\;\F{xs})\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{suc}\;(\F{length}\;\F{xs})\;{}\<[32]%
\>[32]{}\equiv \;[\mskip1.5mu \F{refl}\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\F{length}\;(\F{x},\F{xs})\;{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\D{\Box}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{theorem}
For all numbers n and lists l, length (snoc n l) = suc (length l).
\end{theorem}
\begin{proof}
We will proceed by induction \ensuremath{\F{l}}.
\begin{itemize}
  \item Caso \ensuremath{\F{l}\;\mathrel{=}\;\D{nil}}. We have that:
  \begin{center}
    \begin{tabular}{lcl}
      \ensuremath{\F{length}\;(\F{snoc}\;\F{n}\;\D{nil})} & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{length}\;(\F{n},\D{nil})}    & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{suc}\;\F{zero}}           & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{suc}\;(\F{length}\;\D{nil})}
    \end{tabular}
  \end{center}
  as required.
  \item Caso \ensuremath{\F{l}\;\mathrel{=}\;\F{x},\F{xs}}. We have that:
  \begin{center}
    \begin{tabular}{lcl}
      \ensuremath{\F{length}\;(\F{snoc}\;\F{n}\;(\F{x},\F{xs}))} & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{length}\;(\F{x},\F{snoc}\;\F{n}\;\F{xs})}  & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{suc}\;(\F{length}\;(\F{snoc}\;\F{n}\;\F{xs}))} & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{suc}\;(\F{suc}\;(\F{length}\;\F{xs}))}    & $\equiv$ & \{by I.H.\} \\
      \ensuremath{\F{suc}\;(\F{length}\;(\F{x},\F{xs}))} 
    \end{tabular}
  \end{center}
  as required.
\end{itemize}
\end{proof}

\begin{theorem}
Theorem: For all lists l, length (rev l) = length l.
\end{theorem}
\begin{proof}
We will proceed by induction \ensuremath{\F{l}}.
\begin{itemize}
  \item Case \ensuremath{\F{l}\;\mathrel{=}\;\F{nil}}. We have that:
  \begin{center}
    \begin{tabular}{lcl}
      \ensuremath{\F{length}\;(\F{rev}\;\D{nil})} & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{length}\;\D{nil}}       & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{zero}}            & $\equiv$ & \{by def.\} \\
      \ensuremath{\F{length}\;\D{nil}}
    \end{tabular}
  \end{center}
  as required.
  \item Case \ensuremath{\F{l}\;\mathrel{=}\;\F{x},\F{xs}}. We have that:
  \begin{center}
    \begin{tabular}{lcl}
      length (rev (x , xs)) & $\equiv$ & \{by def.\} \\
      length (snoc x (rev xs)) & $\equiv$ & \{by lengthSnoc\} \\
      suc (length (rev xs)) & $\equiv$ & \{by I.H.\} \\
      suc (length xs)
    \end{tabular}
  \end{center}
  as required.
\end{itemize}
\end{proof}

\subsection{List Exercices, Part 1}

More practice with lists.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{appNilEnd}\;\mathbin{:}\;\mathkw{forall}\;(\F{l}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{l}\;\F{++}\;\D{nil}\;\equiv \;\F{l}{}\<[E]%
\\
\>[B]{}\F{appNilEnd}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{revInvolutive}\;\mathbin{:}\;\mathkw{forall}\;(\F{l}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{rev}\;(\F{rev}\;\F{l})\;\equiv \;\F{l}{}\<[E]%
\\
\>[B]{}\F{revInvolutive}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{1}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

There is a short solution to the next exercise. If you find yourself getting tangled up, 
step back and try to look for a simpler way.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{appAss4}\;\mathbin{:}\;\mathkw{forall}\;(\F{l1}\;\F{l2}\;\F{l3}\;\F{l4}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{l1}\;\F{++}\;(\F{l2}\;\F{++}\;(\F{l3}\;\F{++}\;\F{l4}))\;\equiv \;((\F{l1}\;\F{++}\;\F{l2})\;\F{++}\;\F{l3})\;\F{++}\;\F{l4}{}\<[E]%
\\
\>[B]{}\F{appAss4}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{snocApp}\;\mathbin{:}\;\mathkw{forall}\;(\F{l}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{snoc}\;\F{n}\;\F{l}\;\equiv \;\F{l}\;\F{++}\;(\F{n},\D{nil}){}\<[E]%
\\
\>[B]{}\F{snocApp}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{1}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{distrRev}\;\mathbin{:}\;\mathkw{forall}\;(\F{l1}\;\F{l2}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{rev}\;(\F{l1}\;\F{++}\;\F{l2})\;\equiv \;\F{rev}\;\F{l2}\;\F{++}\;\F{rev}\;\F{l1}{}\<[E]%
\\
\>[B]{}\F{distrRev}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{2}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\F{revInjective}\;\mathbin{:}\;\mathkw{forall}\;(\F{l}\;\F{l'}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{rev}\;\F{l}\;\equiv \;\F{rev}\;\F{l'}\;\blue{\rightarrow}\;\F{l}\;\equiv \;\F{l'}{}\<[E]%
\\
\>[B]{}\F{revInjective}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{3}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Maybe}

Here is another type definition that is often useful in day-to-day programming:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\V{NatMaybe}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Just}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{NatMaybe}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\V{Nothing}\;\mathbin{:}\;\V{NatMaybe}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
One use of natoption is as a way of returning ``error codes'' from functions. 
For example, suppose we want to write a function that returns the nth element of some list. 
If we give it type \ensuremath{\V{Nat}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{Nat}}, then we'll have to return some number when the list is too short!
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{indexBad}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{Nat}{}\<[E]%
\\
\>[B]{}\F{indexBad}\;\anonymous \;\D{nil}\;\mathrel{=}\;\F{42}\mbox{\onelinecomment  arbitrary...}{}\<[E]%
\\
\>[B]{}\F{indexBad}\;\F{zero}\;(\F{x},\F{xs})\;\mathrel{=}\;\F{x}{}\<[E]%
\\
\>[B]{}\F{indexBad}\;(\F{suc}\;\F{n})\;(\anonymous ,\F{xs})\;\mathrel{=}\;\F{indexBad}\;\F{n}\;\F{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
On the other hand, if we give it type \ensuremath{\V{Nat}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{NatMaybe}}, then we can return \ensuremath{\V{Nothing}} when the 
list is too short and \ensuremath{\V{Just}\;\F{a}} when the list has enough members and \ensuremath{\F{a}} appears at position \ensuremath{\F{n}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{index}\;\mathbin{:}\;\V{Nat}\;\blue{\rightarrow}\;\V{NList}\;\blue{\rightarrow}\;\V{NatMaybe}{}\<[E]%
\\
\>[B]{}\F{index}\;\anonymous \;\D{nil}\;\mathrel{=}\;\V{Nothing}{}\<[E]%
\\
\>[B]{}\F{index}\;\F{zero}\;(\F{x},\anonymous )\;\mathrel{=}\;\V{Just}\;\F{x}{}\<[E]%
\\
\>[B]{}\F{index}\;(\F{suc}\;\F{n})\;(\anonymous ,\F{xs})\;\mathrel{=}\;\F{index}\;\F{n}\;\F{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{exe}[Head]
Implement the function \ensuremath{\F{head}} from earlier so we don't have to pass a default element for the \ensuremath{\D{nil}} case.
\end{exe}

\begin{exe}[Equality of NLists]
Define a function \ensuremath{\F{beqNList}} that tests the equality of two given \ensuremath{\V{NList}}s and prove the following property:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{beqNList}\;\mathbin{:}\;\mathkw{forall}\;(\F{l}\;\mathbin{:}\;\V{NList})\;\blue{\rightarrow}\;\F{beqNList}\;\F{l}\;\F{l}{}\<[E]%
\\
\>[B]{}\F{beqNList}\;\mathrel{=}\;\{\mskip1.5mu \;\mskip1.5mu\}\!_{\F{0}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{exe}



\end{document}
